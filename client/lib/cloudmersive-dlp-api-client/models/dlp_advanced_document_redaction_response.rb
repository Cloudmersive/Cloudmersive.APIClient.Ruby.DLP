=begin
#dlpapi

#Easily and directly scan and detect sensitive data (PII) in input text.

OpenAPI spec version: v1

Generated by: https://github.com/swagger-api/swagger-codegen.git
Swagger Codegen version: 2.4.14

=end

require 'date'

module CloudmersiveDlpApiClient
  # Response object for advanced DLP document redaction with 35 PII detection results, redacted document, and optional rationale.
  class DlpAdvancedDocumentRedactionResponse
    # The redacted document as a rasterized PDF with PII regions redacted, or the original file if no disallowed PII was found.
    attr_accessor :redacted_document

    # True if no disallowed PII or sensitive data types were detected; false if any disallowed type was found and redacted.
    attr_accessor :clean_result

    # True if the document contains email addresses.
    attr_accessor :contains_email_address

    # True if the document contains phone numbers.
    attr_accessor :contains_phone_number

    # True if the document contains street addresses.
    attr_accessor :contains_street_address

    # True if the document contains person names.
    attr_accessor :contains_person_name

    # True if the document contains birth dates.
    attr_accessor :contains_birth_date

    # True if the document contains passport numbers.
    attr_accessor :contains_passport_number

    # True if the document contains drivers license numbers.
    attr_accessor :contains_drivers_license

    # True if the document contains social security numbers.
    attr_accessor :contains_social_security_number

    # True if the document contains taxpayer IDs.
    attr_accessor :contains_taxpayer_id

    # True if the document contains credit card numbers.
    attr_accessor :contains_credit_card_number

    # True if the document contains credit card expiration dates.
    attr_accessor :contains_credit_card_expiration_date

    # True if the document contains credit card verification codes.
    attr_accessor :contains_credit_card_verification_code

    # True if the document contains bank account numbers.
    attr_accessor :contains_bank_account_number

    # True if the document contains IBANs.
    attr_accessor :contains_iban

    # True if the document contains health insurance numbers.
    attr_accessor :contains_health_insurance_number

    # True if the document contains bearer tokens.
    attr_accessor :contains_bearer_token

    # True if the document contains HTTP cookies.
    attr_accessor :contains_http_cookie

    # True if the document contains private keys.
    attr_accessor :contains_private_keys

    # True if the document contains credentials (usernames/passwords).
    attr_accessor :contains_credentials

    # True if the document contains deep web URLs (.onion).
    attr_accessor :contains_deep_web_urls

    # True if the document contains source code.
    attr_accessor :contains_source_code

    # True if the document contains IP addresses.
    attr_accessor :contains_ip_address

    # True if the document contains MAC addresses.
    attr_accessor :contains_mac_address

    # True if the document contains health insurance member IDs.
    attr_accessor :contains_health_insurance_member_id

    # True if the document contains references to injuries or diseases.
    attr_accessor :contains_health_injury_or_disease

    # True if the document contains references to types of medical treatment.
    attr_accessor :contains_health_type_of_treatment

    # True if the document contains dates and times of medical treatment.
    attr_accessor :contains_health_date_and_time_of_treatment

    # True if the document contains health plan beneficiary numbers.
    attr_accessor :contains_health_plan_beneficiary_number

    # True if the document contains payments made for medical treatment.
    attr_accessor :contains_health_payments_made_for_treatment

    # True if the document contains identifiable human faces.
    attr_accessor :contains_faces

    # True if the document contains vehicle identifiers (e.g. license plates, VINs).
    attr_accessor :contains_vehicle_id

    # True if the document contains device identifiers (e.g. serial numbers, IMEIs, MAC-level device IDs).
    attr_accessor :contains_device_id

    # True if the document contains names of relatives.
    attr_accessor :contains_names_of_relatives

    # True if the document contains health universal record locators (URLs).
    attr_accessor :contains_health_universal_record_locator

    # True if the document contains biometric data references (e.g. fingerprints, retinal scans, voiceprints).
    attr_accessor :contains_biometrics

    # List of pages that were redacted (had PII regions redacted).
    attr_accessor :pages_redacted

    # Rationale for why the conclusion was formed. Only populated when ProvideAnalysisRationale is set to true in the request.
    attr_accessor :analysis_rationale

    # Attribute mapping from ruby-style variable name to JSON key.
    def self.attribute_map
      {
        :'redacted_document' => :'RedactedDocument',
        :'clean_result' => :'CleanResult',
        :'contains_email_address' => :'ContainsEmailAddress',
        :'contains_phone_number' => :'ContainsPhoneNumber',
        :'contains_street_address' => :'ContainsStreetAddress',
        :'contains_person_name' => :'ContainsPersonName',
        :'contains_birth_date' => :'ContainsBirthDate',
        :'contains_passport_number' => :'ContainsPassportNumber',
        :'contains_drivers_license' => :'ContainsDriversLicense',
        :'contains_social_security_number' => :'ContainsSocialSecurityNumber',
        :'contains_taxpayer_id' => :'ContainsTaxpayerID',
        :'contains_credit_card_number' => :'ContainsCreditCardNumber',
        :'contains_credit_card_expiration_date' => :'ContainsCreditCardExpirationDate',
        :'contains_credit_card_verification_code' => :'ContainsCreditCardVerificationCode',
        :'contains_bank_account_number' => :'ContainsBankAccountNumber',
        :'contains_iban' => :'ContainsIBAN',
        :'contains_health_insurance_number' => :'ContainsHealthInsuranceNumber',
        :'contains_bearer_token' => :'ContainsBearerToken',
        :'contains_http_cookie' => :'ContainsHttpCookie',
        :'contains_private_keys' => :'ContainsPrivateKeys',
        :'contains_credentials' => :'ContainsCredentials',
        :'contains_deep_web_urls' => :'ContainsDeepWebUrls',
        :'contains_source_code' => :'ContainsSourceCode',
        :'contains_ip_address' => :'ContainsIpAddress',
        :'contains_mac_address' => :'ContainsMacAddress',
        :'contains_health_insurance_member_id' => :'ContainsHealthInsuranceMemberID',
        :'contains_health_injury_or_disease' => :'ContainsHealthInjuryOrDisease',
        :'contains_health_type_of_treatment' => :'ContainsHealthTypeOfTreatment',
        :'contains_health_date_and_time_of_treatment' => :'ContainsHealthDateAndTimeOfTreatment',
        :'contains_health_plan_beneficiary_number' => :'ContainsHealthPlanBeneficiaryNumber',
        :'contains_health_payments_made_for_treatment' => :'ContainsHealthPaymentsMadeForTreatment',
        :'contains_faces' => :'ContainsFaces',
        :'contains_vehicle_id' => :'ContainsVehicleID',
        :'contains_device_id' => :'ContainsDeviceID',
        :'contains_names_of_relatives' => :'ContainsNamesOfRelatives',
        :'contains_health_universal_record_locator' => :'ContainsHealthUniversalRecordLocator',
        :'contains_biometrics' => :'ContainsBiometrics',
        :'pages_redacted' => :'PagesRedacted',
        :'analysis_rationale' => :'AnalysisRationale'
      }
    end

    # Attribute type mapping.
    def self.swagger_types
      {
        :'redacted_document' => :'String',
        :'clean_result' => :'BOOLEAN',
        :'contains_email_address' => :'BOOLEAN',
        :'contains_phone_number' => :'BOOLEAN',
        :'contains_street_address' => :'BOOLEAN',
        :'contains_person_name' => :'BOOLEAN',
        :'contains_birth_date' => :'BOOLEAN',
        :'contains_passport_number' => :'BOOLEAN',
        :'contains_drivers_license' => :'BOOLEAN',
        :'contains_social_security_number' => :'BOOLEAN',
        :'contains_taxpayer_id' => :'BOOLEAN',
        :'contains_credit_card_number' => :'BOOLEAN',
        :'contains_credit_card_expiration_date' => :'BOOLEAN',
        :'contains_credit_card_verification_code' => :'BOOLEAN',
        :'contains_bank_account_number' => :'BOOLEAN',
        :'contains_iban' => :'BOOLEAN',
        :'contains_health_insurance_number' => :'BOOLEAN',
        :'contains_bearer_token' => :'BOOLEAN',
        :'contains_http_cookie' => :'BOOLEAN',
        :'contains_private_keys' => :'BOOLEAN',
        :'contains_credentials' => :'BOOLEAN',
        :'contains_deep_web_urls' => :'BOOLEAN',
        :'contains_source_code' => :'BOOLEAN',
        :'contains_ip_address' => :'BOOLEAN',
        :'contains_mac_address' => :'BOOLEAN',
        :'contains_health_insurance_member_id' => :'BOOLEAN',
        :'contains_health_injury_or_disease' => :'BOOLEAN',
        :'contains_health_type_of_treatment' => :'BOOLEAN',
        :'contains_health_date_and_time_of_treatment' => :'BOOLEAN',
        :'contains_health_plan_beneficiary_number' => :'BOOLEAN',
        :'contains_health_payments_made_for_treatment' => :'BOOLEAN',
        :'contains_faces' => :'BOOLEAN',
        :'contains_vehicle_id' => :'BOOLEAN',
        :'contains_device_id' => :'BOOLEAN',
        :'contains_names_of_relatives' => :'BOOLEAN',
        :'contains_health_universal_record_locator' => :'BOOLEAN',
        :'contains_biometrics' => :'BOOLEAN',
        :'pages_redacted' => :'Array<RedactedPageInfo>',
        :'analysis_rationale' => :'String'
      }
    end

    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    def initialize(attributes = {})
      return unless attributes.is_a?(Hash)

      # convert string to symbol for hash key
      attributes = attributes.each_with_object({}) { |(k, v), h| h[k.to_sym] = v }

      if attributes.has_key?(:'RedactedDocument')
        self.redacted_document = attributes[:'RedactedDocument']
      end

      if attributes.has_key?(:'CleanResult')
        self.clean_result = attributes[:'CleanResult']
      end

      if attributes.has_key?(:'ContainsEmailAddress')
        self.contains_email_address = attributes[:'ContainsEmailAddress']
      end

      if attributes.has_key?(:'ContainsPhoneNumber')
        self.contains_phone_number = attributes[:'ContainsPhoneNumber']
      end

      if attributes.has_key?(:'ContainsStreetAddress')
        self.contains_street_address = attributes[:'ContainsStreetAddress']
      end

      if attributes.has_key?(:'ContainsPersonName')
        self.contains_person_name = attributes[:'ContainsPersonName']
      end

      if attributes.has_key?(:'ContainsBirthDate')
        self.contains_birth_date = attributes[:'ContainsBirthDate']
      end

      if attributes.has_key?(:'ContainsPassportNumber')
        self.contains_passport_number = attributes[:'ContainsPassportNumber']
      end

      if attributes.has_key?(:'ContainsDriversLicense')
        self.contains_drivers_license = attributes[:'ContainsDriversLicense']
      end

      if attributes.has_key?(:'ContainsSocialSecurityNumber')
        self.contains_social_security_number = attributes[:'ContainsSocialSecurityNumber']
      end

      if attributes.has_key?(:'ContainsTaxpayerID')
        self.contains_taxpayer_id = attributes[:'ContainsTaxpayerID']
      end

      if attributes.has_key?(:'ContainsCreditCardNumber')
        self.contains_credit_card_number = attributes[:'ContainsCreditCardNumber']
      end

      if attributes.has_key?(:'ContainsCreditCardExpirationDate')
        self.contains_credit_card_expiration_date = attributes[:'ContainsCreditCardExpirationDate']
      end

      if attributes.has_key?(:'ContainsCreditCardVerificationCode')
        self.contains_credit_card_verification_code = attributes[:'ContainsCreditCardVerificationCode']
      end

      if attributes.has_key?(:'ContainsBankAccountNumber')
        self.contains_bank_account_number = attributes[:'ContainsBankAccountNumber']
      end

      if attributes.has_key?(:'ContainsIBAN')
        self.contains_iban = attributes[:'ContainsIBAN']
      end

      if attributes.has_key?(:'ContainsHealthInsuranceNumber')
        self.contains_health_insurance_number = attributes[:'ContainsHealthInsuranceNumber']
      end

      if attributes.has_key?(:'ContainsBearerToken')
        self.contains_bearer_token = attributes[:'ContainsBearerToken']
      end

      if attributes.has_key?(:'ContainsHttpCookie')
        self.contains_http_cookie = attributes[:'ContainsHttpCookie']
      end

      if attributes.has_key?(:'ContainsPrivateKeys')
        self.contains_private_keys = attributes[:'ContainsPrivateKeys']
      end

      if attributes.has_key?(:'ContainsCredentials')
        self.contains_credentials = attributes[:'ContainsCredentials']
      end

      if attributes.has_key?(:'ContainsDeepWebUrls')
        self.contains_deep_web_urls = attributes[:'ContainsDeepWebUrls']
      end

      if attributes.has_key?(:'ContainsSourceCode')
        self.contains_source_code = attributes[:'ContainsSourceCode']
      end

      if attributes.has_key?(:'ContainsIpAddress')
        self.contains_ip_address = attributes[:'ContainsIpAddress']
      end

      if attributes.has_key?(:'ContainsMacAddress')
        self.contains_mac_address = attributes[:'ContainsMacAddress']
      end

      if attributes.has_key?(:'ContainsHealthInsuranceMemberID')
        self.contains_health_insurance_member_id = attributes[:'ContainsHealthInsuranceMemberID']
      end

      if attributes.has_key?(:'ContainsHealthInjuryOrDisease')
        self.contains_health_injury_or_disease = attributes[:'ContainsHealthInjuryOrDisease']
      end

      if attributes.has_key?(:'ContainsHealthTypeOfTreatment')
        self.contains_health_type_of_treatment = attributes[:'ContainsHealthTypeOfTreatment']
      end

      if attributes.has_key?(:'ContainsHealthDateAndTimeOfTreatment')
        self.contains_health_date_and_time_of_treatment = attributes[:'ContainsHealthDateAndTimeOfTreatment']
      end

      if attributes.has_key?(:'ContainsHealthPlanBeneficiaryNumber')
        self.contains_health_plan_beneficiary_number = attributes[:'ContainsHealthPlanBeneficiaryNumber']
      end

      if attributes.has_key?(:'ContainsHealthPaymentsMadeForTreatment')
        self.contains_health_payments_made_for_treatment = attributes[:'ContainsHealthPaymentsMadeForTreatment']
      end

      if attributes.has_key?(:'ContainsFaces')
        self.contains_faces = attributes[:'ContainsFaces']
      end

      if attributes.has_key?(:'ContainsVehicleID')
        self.contains_vehicle_id = attributes[:'ContainsVehicleID']
      end

      if attributes.has_key?(:'ContainsDeviceID')
        self.contains_device_id = attributes[:'ContainsDeviceID']
      end

      if attributes.has_key?(:'ContainsNamesOfRelatives')
        self.contains_names_of_relatives = attributes[:'ContainsNamesOfRelatives']
      end

      if attributes.has_key?(:'ContainsHealthUniversalRecordLocator')
        self.contains_health_universal_record_locator = attributes[:'ContainsHealthUniversalRecordLocator']
      end

      if attributes.has_key?(:'ContainsBiometrics')
        self.contains_biometrics = attributes[:'ContainsBiometrics']
      end

      if attributes.has_key?(:'PagesRedacted')
        if (value = attributes[:'PagesRedacted']).is_a?(Array)
          self.pages_redacted = value
        end
      end

      if attributes.has_key?(:'AnalysisRationale')
        self.analysis_rationale = attributes[:'AnalysisRationale']
      end
    end

    # Show invalid properties with the reasons. Usually used together with valid?
    # @return Array for valid properties with the reasons
    def list_invalid_properties
      invalid_properties = Array.new
      if !@redacted_document.nil? && @redacted_document !~ Regexp.new(/^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/)
        invalid_properties.push('invalid value for "redacted_document", must conform to the pattern /^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.')
      end

      invalid_properties
    end

    # Check to see if the all the properties in the model are valid
    # @return true if the model is valid
    def valid?
      return false if !@redacted_document.nil? && @redacted_document !~ Regexp.new(/^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/)
      true
    end

    # Custom attribute writer method with validation
    # @param [Object] redacted_document Value to be assigned
    def redacted_document=(redacted_document)
      if !redacted_document.nil? && redacted_document !~ Regexp.new(/^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/)
        fail ArgumentError, 'invalid value for "redacted_document", must conform to the pattern /^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.'
      end

      @redacted_document = redacted_document
    end

    # Checks equality by comparing each attribute.
    # @param [Object] Object to be compared
    def ==(o)
      return true if self.equal?(o)
      self.class == o.class &&
          redacted_document == o.redacted_document &&
          clean_result == o.clean_result &&
          contains_email_address == o.contains_email_address &&
          contains_phone_number == o.contains_phone_number &&
          contains_street_address == o.contains_street_address &&
          contains_person_name == o.contains_person_name &&
          contains_birth_date == o.contains_birth_date &&
          contains_passport_number == o.contains_passport_number &&
          contains_drivers_license == o.contains_drivers_license &&
          contains_social_security_number == o.contains_social_security_number &&
          contains_taxpayer_id == o.contains_taxpayer_id &&
          contains_credit_card_number == o.contains_credit_card_number &&
          contains_credit_card_expiration_date == o.contains_credit_card_expiration_date &&
          contains_credit_card_verification_code == o.contains_credit_card_verification_code &&
          contains_bank_account_number == o.contains_bank_account_number &&
          contains_iban == o.contains_iban &&
          contains_health_insurance_number == o.contains_health_insurance_number &&
          contains_bearer_token == o.contains_bearer_token &&
          contains_http_cookie == o.contains_http_cookie &&
          contains_private_keys == o.contains_private_keys &&
          contains_credentials == o.contains_credentials &&
          contains_deep_web_urls == o.contains_deep_web_urls &&
          contains_source_code == o.contains_source_code &&
          contains_ip_address == o.contains_ip_address &&
          contains_mac_address == o.contains_mac_address &&
          contains_health_insurance_member_id == o.contains_health_insurance_member_id &&
          contains_health_injury_or_disease == o.contains_health_injury_or_disease &&
          contains_health_type_of_treatment == o.contains_health_type_of_treatment &&
          contains_health_date_and_time_of_treatment == o.contains_health_date_and_time_of_treatment &&
          contains_health_plan_beneficiary_number == o.contains_health_plan_beneficiary_number &&
          contains_health_payments_made_for_treatment == o.contains_health_payments_made_for_treatment &&
          contains_faces == o.contains_faces &&
          contains_vehicle_id == o.contains_vehicle_id &&
          contains_device_id == o.contains_device_id &&
          contains_names_of_relatives == o.contains_names_of_relatives &&
          contains_health_universal_record_locator == o.contains_health_universal_record_locator &&
          contains_biometrics == o.contains_biometrics &&
          pages_redacted == o.pages_redacted &&
          analysis_rationale == o.analysis_rationale
    end

    # @see the `==` method
    # @param [Object] Object to be compared
    def eql?(o)
      self == o
    end

    # Calculates hash code according to all attributes.
    # @return [Fixnum] Hash code
    def hash
      [redacted_document, clean_result, contains_email_address, contains_phone_number, contains_street_address, contains_person_name, contains_birth_date, contains_passport_number, contains_drivers_license, contains_social_security_number, contains_taxpayer_id, contains_credit_card_number, contains_credit_card_expiration_date, contains_credit_card_verification_code, contains_bank_account_number, contains_iban, contains_health_insurance_number, contains_bearer_token, contains_http_cookie, contains_private_keys, contains_credentials, contains_deep_web_urls, contains_source_code, contains_ip_address, contains_mac_address, contains_health_insurance_member_id, contains_health_injury_or_disease, contains_health_type_of_treatment, contains_health_date_and_time_of_treatment, contains_health_plan_beneficiary_number, contains_health_payments_made_for_treatment, contains_faces, contains_vehicle_id, contains_device_id, contains_names_of_relatives, contains_health_universal_record_locator, contains_biometrics, pages_redacted, analysis_rationale].hash
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)
      self.class.swagger_types.each_pair do |key, type|
        if type =~ /\AArray<(.*)>/i
          # check to ensure the input is an array given that the attribute
          # is documented as an array but the input is not
          if attributes[self.class.attribute_map[key]].is_a?(Array)
            self.send("#{key}=", attributes[self.class.attribute_map[key]].map { |v| _deserialize($1, v) })
          end
        elsif !attributes[self.class.attribute_map[key]].nil?
          self.send("#{key}=", _deserialize(type, attributes[self.class.attribute_map[key]]))
        end # or else data not found in attributes(hash), not an issue as the data can be optional
      end

      self
    end

    # Deserializes the data based on type
    # @param string type Data type
    # @param string value Value to be deserialized
    # @return [Object] Deserialized data
    def _deserialize(type, value)
      case type.to_sym
      when :DateTime
        DateTime.parse(value)
      when :Date
        Date.parse(value)
      when :String
        value.to_s
      when :Integer
        value.to_i
      when :Float
        value.to_f
      when :BOOLEAN
        if value.to_s =~ /\A(true|t|yes|y|1)\z/i
          true
        else
          false
        end
      when :Object
        # generic object (usually a Hash), return directly
        value
      when /\AArray<(?<inner_type>.+)>\z/
        inner_type = Regexp.last_match[:inner_type]
        value.map { |v| _deserialize(inner_type, v) }
      when /\AHash<(?<k_type>.+?), (?<v_type>.+)>\z/
        k_type = Regexp.last_match[:k_type]
        v_type = Regexp.last_match[:v_type]
        {}.tap do |hash|
          value.each do |k, v|
            hash[_deserialize(k_type, k)] = _deserialize(v_type, v)
          end
        end
      else # model
        temp_model = CloudmersiveDlpApiClient.const_get(type).new
        temp_model.build_from_hash(value)
      end
    end

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_hash.to_s
    end

    # to_body is an alias to to_hash (backward compatibility)
    # @return [Hash] Returns the object in the form of hash
    def to_body
      to_hash
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {}
      self.class.attribute_map.each_pair do |attr, param|
        value = self.send(attr)
        next if value.nil?
        hash[param] = _to_hash(value)
      end
      hash
    end

    # Outputs non-array value in the form of hash
    # For object, use to_hash. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    def _to_hash(value)
      if value.is_a?(Array)
        value.compact.map { |v| _to_hash(v) }
      elsif value.is_a?(Hash)
        {}.tap do |hash|
          value.each { |k, v| hash[k] = _to_hash(v) }
        end
      elsif value.respond_to? :to_hash
        value.to_hash
      else
        value
      end
    end

  end
end
